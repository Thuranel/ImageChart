<div class="row" ng-controller="AboutCtrl">
    <div id="index">
        <h2> Publication des résultats: </h2>
        <ul>
            <li>  <a ng-click="scrollTo('propositionRecherche')"> Proposition de recherche: </a>
                <ul>
                    <li> <a ng-click="scrollTo('propositionSujet')"> Sujet </a> </li>
                    <li> <a ng-click="scrollTo('propositionEnjeu')"> Enjeu </a> </li>
                    <li> <a ng-click="scrollTo('propositionExperimentation')"> Expérimentation </a> </li>
                    <li> <a ng-click="scrollTo('propositionRessources')"> Ressources </a> </li>
                    <li> <a ng-click="scrollTo('propositionLimites')"> Limites </a> </li>
                </ul>
            </li>
            <li> <a ng-click="scrollTo('acquisitionConnaissances')"> Acquisition des connaissances </a>
                <ul>
                    <li> <a ng-click="scrollTo('acquisitionGraphique')"> Base du graphique </a> </li>
                    <li> <a ng-click="scrollTo('acquisitionTip')"> Tip </a> </li>
                    <li> <a ng-click="scrollTo('acquisitionImages')"> Insertion des images </a> </li>
                    <li> <a ng-click="scrollTo('acquisitionCategorisation')"> Catégorisation </a> </li>
                    <li> <a ng-click="scrollTo('acquisitionZoom')"> Zoom </a> </li>
                </ul>
            </li>
            <li> <a ng-click="scrollTo('demarcheExperimentale')"> Démarche expérimentale </a> </li>
            <li> <a ng-click="scrollTo('difficultes')"> Difficultés </a> </li>
            <li> <a ng-click="scrollTo('analyseResultats')"> Analyse des résultats </a> </li>
            <li> <a ng-click="scrollTo('conclusionRecherche')"> Conclusion de la recherche </a> </li>
            <li> <a ng-click="scrollTo('biliographie')"> Bibliographie </a> </li>
        </ul>
    </div>
    <br>
    <div class="text-justify">
        <div id="propositionRecherche">
            <h3> Proposition de recherche </h3>
            <br>
            <div id="propositionSujet">
                <h4> Sujet </h4>
                <p> Le but de cette recherche est de créer une application web permettant d’identifier des points sur un graphique grâce à des images. En effet, il existe plusieurs librairies de visualisation, mais aucune ne permet de faire cette fonction directement. Par exemple, il existe Google charts, Angular-nvD3, etc. </p>
                <p> Pouvoir ajouter des images pour identifier des points dans un graphique permet de rajouter une autre dimension à la façon de présenter des statistiques. Bien que l’utilisation de cette fonctionnalité est très spécifique à certains cas, l’ajout d’une telle fonctionnalité permet de clarifier les informations présentées dans le graphique. Par exemple, si l’on veut comparer la taille et le poids des athlètes de la NHL il serait possible de faire un graphique avec la taille des athlètes comme l’axe des X et leur poids comme l’axe des Y et en plus d’ajouter la photo des joueurs sur le point leur correspondant pour visualiser où se situe chaque joueur dans le graphique avec un seul coup d’oeil. </p>
                <p> Pour pouvoir atteindre ce but, il est nécessaire d’apprendre à utiliser une librairie de visualisation. Pour faire ce projet, nous avons décidé d’utiliser D3.js. Celui-ci offre plusieurs avantages comparés à d’autres librairies graphiques. Un de ses avantages principaux est qu’il permet de faire plus de choses. En effet, D3 permet de manipuler le DOM, donc il n’est pas limité à créer des graphiques. Autrement dit, avec cette librairie il est plus facile de manipuler les images. En plus, D3 fonctionne directement avec le HTML, le SVG et le CSS ce qui fait en sorte qu’il est plus facilement compatible avec tous les navigateurs. </p>
                <p> Au début de ce projet, D3 était une librairie nouvelle pour nous, mais nous pouvons maintenant dire que nous comprenons bien comment elle fonctionne et nous avons désormais une maîtrise suffisante pour compléter et améliorer ce projet. </p>
            </div>
            <br>
            <div id="propositionEnjeu">
                <h4> Enjeu </h4>
                <p> Ce projet de recherche est important, car il nous permet de consolider certaines connaissances sur les technologies présentes sur le web en ce moment même et de développer une façon d’approfondir le domaine d’application des statistiques.</p>
                <p> En effet, la clarté des informations est un des points les plus importants lorsque l’on présente des statistiques. Un graphique doit être complet (avoir toutes les informations nécessaires), facile à comprendre et facilement accessible.</p>
                <p> C’est ce que vise exactement notre application. Notre graphique est déjà complet, mais il présente quelques avantages que des applications graphiques n’ont pas toujours. Premièrement, il est accessible directement sur le web. Une fois que le graphique a été mis en ligne, il n’est pas nécessaire d’installer d’application pour pouvoir voir les données et l’utiliser ce qui offre un avantage par rapport à certains logiciels de visualisation qui demandent de faire des installation. En plus, ajouter des images dans notre graphique permet de rendre les informations plus faciles à comprendre. En effet, il n’est pas nécessaire de fouiller dans de la documentation pour savoir ce que chaque représente puisque l’image nous donne l’information nécessaire avec un seul coup d’oeil. </p>
                <p> Notre motivation pour faire ce projet vient du fait qu’il n’existe pas encore de façon facile de créer des graphiques où l’on peut remplacer les points par des images et ainsi clarifier les données de recherche. </p>
                <p> Une fois complété, le projet permettra de présenter des statistiques plus clairement. Par exemple, on pourrait utiliser notre méthode pour présenter des statistiques de comparaisons de joueurs de sports grâce à leur photos, de comparaisons de personnages dans un jeu vidéo grâce à leur avatar ou de comparaisons de statistiques sur l’économie de différents pays grâce à leur drapeaux. </p>
            </div>
            <br>
            <div id="propositionExperimentation">
                <h4> Expérimentation </h4>
                <p> Notre projet de recherche a été fait grâce à l’aide d’outils d’expérimentation. C’est-à-dire que nous avons tenté d’utiliser des outils pour tenter de voir le résultat concret de nos recherches dans un contexte semblable à la réalité. </p>
                <p> Pour faire cela, nous avons tenté de cibler quelles technologies pourraient nous aider à réaliser notre projet. Nous avons tenté d’utiliser ces technologies pour comprendre quel rôle chacune d’entre elles pourrait servir dans l’application et pour trouver quel serait la technologie la plus adaptée. </p>
                <p> Au début du projet, nous avions comme idée d’utiliser le cadriciel JavaScript React. Au cours de notre expérimentation, nous avons découvert que celui-ci n’était pas très adapté à nos besoins. Par conséquent, nous avons décidé de retourner vers une valeur plus sûre et que nous connaissions mieux. C’est-à-dire le cadriciel Angular. Nous avons fait ce même processus pour trouver quelle librairie graphique serait la meilleure pour présenter nos données. Au départ, nous avons tenté d’utiliser React-D3, puis Google Charts, mais aucune de ces librairies n'offrait la liberté que nous voulions avoir. C’est à ce point que nous avons trouvé D3 qui nous permettait de faire plus de choses et que nous avons approfondi nos connaissances sur cette librairie. </p>
                <p> Cette méthode d’expérimentation est bien adaptée à notre projet de recherche puisque le but initial était de créer un outil qui nous permettrait de mettre des images dans notre graphique et pour arriver à ce but nous avions besoin de premièrement trouver une librairie graphique à laquelle nous pourrions rajouter cette fonctionnalité. Par conséquent, nous étions forcés d’utiliser l’expérimentation pour trouver avec quelle librairie il serait possible de travailler pour arriver à notre but. </p>
                <p> Une des failles de notre méthode d’expérimentation serait que nous sommes dans l’incertitude si une autre librairie graphique nous aurait permis d’arriver au même ou sinon à un résultat meilleur. En effet, nous n’avons pas pu essayer toutes les librairies graphiques puisque nous étions limité dans le temps, mais le résultat que nous avons atteint démontre que notre méthode d’expérimentation était adapté. </p>
            </div>
            <br>
            <div id="propositionRessources">
                <h4> Ressources </h4>
                <p> Pour pouvoir faire ce projet, nous avons créé une application grâce à Node.js qui utilise une multitude de technologies afin de simplifier le développement et l’intégration de toutes nos composantes. </p>
                <p> <a href="https://nodejs.org/" > Node.js</a> est un runtime JavaScript créé pour faire des applications serveur facilement extensibles. Node.js est un outil de développement qui permet de faciliter la communication entre le client et le serveur en créant une connexion à deux voies. Cela permet d’échanger de l’information plus librement entre le client et le serveur. Ceci est en contraste avec le web standard où le client devait faire toutes les demandes. </p>
                <p> <a href="https://www.npmjs.com/" > Npm</a> ou le Node Package Manager est un gestionnaire de dépendances qui propose des milliers de composantes pour simplifier l’implémentation de fonctionnalités dans une application web. Npm est utilisé pour gérer les composantes du côté serveur de façon à permettre la communication plus facilement avec le client. </p>
                <p> L’application est basée sur une base d’Angular générée par Yeoman. </p>
                <p> <a href="https://angularjs.org/" > Angular</a> est un cadriciel JavaScript créé par Google. Angular a été créé dans le but de plus facilement créer des applications dynamiques. Le cadriciel nous permet de lier dynamiquement des variables entre le DOM et le code pour faire en sorte que l’interface change automatiquement lorsque l’on change les variables dans le code. Il nous permet aussi de nous créer nos propres composantes pour ainsi simplifier l’intégration de vues dans notre code. </p>
                <p> <a href="http://yeoman.io/" > Yeoman</a> est un générateur d’applications web. Il permet aux utilisateurs de se créer des bases de projet selon la technologie qu’ils veulent utiliser. Les générateurs créés par les utilisateurs de Yeoman couvrent une grande quantité de produits. Il existe des générateurs pour Angular, Angular2, React, Flux, Redux, ASP.net, etc. Le générateur nous permet de créer l’architecture de base pour notre projet. En plus, le générateur nous crée automatiquement des fichiers de configuration pour le serveur et pour installer les dépendances. Dans certains cas, le générateur offre même la possibilité de se créer des dossiers de test. Pour pouvoir utiliser Yeoman, il est nécessaire d’avoir préalablement installé Npm. Dans le projet, nous avons utilisé le <a href="https://github.com/yeoman/generator-angular" >générateur angular</a>. </p>
                <p> Le générateur Yeoman generator-angular utilise Bower et Grunt. </p>
                <p> <a href="https://bower.io/" > Bower</a> est un gestionnaire de dépendance côté client. Comme Npm, Bower offre des milliers de composantes pour simplifier l’implémentation de fonctionnalités dans une application web. Ce qui diffère Npm de Bower est l’endroit où ils sont utilisés. Bower va être utilisé du côté client. Grâce à Bower, il est possible d’envoyer toute nos dépendances du côté client pour utiliser des librairies plus facilement. Il permet aussi de mieux gérer les versions de nos composantes et de faire nos mises à jour de celles-ci. Dans le projet, Bower est utilisé pour gérer la librairie D3. </p>
                <p> <a href="http://gruntjs.com/" > Grunt</a> est un task runner JavaScript. Un task runner est un type de composante qui permet de prendre plusieurs actions répétitives et de les rendre automatiques. Cela inclut la minification, la compilation, faire rouler les tests unitaires, etc. Pour utiliser Grunt, il suffit d’installer la composante et de rajouter un fichier de configuration Gruntfile.js qui déclare comment faire la compilation et comment faire rouler les tests. Dans le projet, Grunt est utilisé pour faire rouler le projet en local et rafraîchir le projet à chaque changement dans le code. En plus, il est utilisé pour pouvoir faire exécuter les tests unitaires. </p>
                <p> Les tests sont faits grâce au framework Karma et ils sont écrits avec Jasmine. </p>
                <p> <a href="https://karma-runner.github.io/" > Karma</a> est un framework de test JavaScript. Le framework se crée un serveur local de test où il peut exécuter les tests avec différents navigateurs. Dans notre cas, nous utilisons un faux navigateur nommé phantomJs qui permet de faire rouler des tests en background en utilisant un nombre minimal de ressources. Lorsque Karma exécute les tests, il utilise ce navigateur pour retrouver le résultat de notre code JavaScript et écrit en console le résultat de chaque test. </p>
                <p> <a href="http://jasmine.github.io/" > Jasmine</a> est un framework pour écrire des tests JavaScript. C’est un framework fait pour facilement tester le JavaScript. En effet, Jasmine n’a pas besoin de DOM et n’a pas besoin d’autres composantes pour fonctionner correctement. Jasmine est un framework fait pour tester le comportement et vérifier que le comportement retourne ce que l’on s’attend sans devoir passer par un DOM. </p>
                <p> Pour pouvoir faire afficher nos données, nous avons utilisé la librairie D3. </p>
                <p> <a href="https://d3js.org/" > D3</a> est une librairie JavaScript créée dans le but de pouvoir plus facilement manipuler le DOM selon des données et d’ainsi pouvoir créer des graphiques et autres sortes d’outils de représentation visuelle. D3 utilise des éléments standards d’HTML, de SVG et de CSS pour pouvoir représenter les données qui lui sont données. </p>
                <p> Combiné avec d’autres sous-composantes de D3, la librairie peut devenir extrêmement puissante. En effet, D3 offre des outils tel que D3-zoom pour pouvoir facilement zoomer dans notre élément graphique. D3-tip est une autre composante offerte qui nous permet de visualiser les données exactes d’un point en passant la souris par-dessus celui-ci. </p>
                <p> Ainsi, D3 permet de facilement créer des graphiques en donnant des outils pour faire des axes, des grilles, des légendes, des titres, etc. D3 permet aussi de créer des graphes, des chartes de bulles, des cartes, etc. D3 possède des bases pour une multitude d’outil et ils peuvent tous être utilisés les uns avec les autres pour créer une application complète. </p>
                <p> Pour pouvoir déployer notre application sur le web, nous avons utilisé Heroku. </p>
                <p> <a href="https://www.heroku.com/platform" > Heroku</a> est une plateforme infonuagique basée sur un principe de conteneurs pour permettre de déployer et de faire rouler des applications web. Heroku a une approche centrée sur les applications web pour permettre de facilement livrer un produit en s’assurant d’avoir un besoin minimal de configuration. Heroku offre un environnement avec tous les outils nécessaires pour faire rouler une application et qui est facile à maintenir. En plus, les forfaits de base sont gratuits. </p>
                <p> Pour pouvoir aller chercher nos données, nous avons utilisé un Docker sur lequel roule le site de champion.gg ce qui nous donne accès à sa base de données. </p>
                <p> <a href="https://champion.gg/" > Champion.gg</a> est un site web de statistique pour le populaire jeu League of Legends. Le site web est disponible publiquement sur Github. <a href="https://github.com/joel1st/championweb" >https://github.com/joel1st/championweb</a>. Le projet donne toutes les indications nécessaires pour pouvoir exécuter le projet localement et la base de données est entièrement disponible dans le projet. Cette base de données est faite en MongoDB et il est possible de faire quelques requêtes simples pour avoir toutes les statistiques venant du site web. </p>
                <p> <a href="https://www.docker.com/" > Docker est</a> un outil de développement qui permet de faire rouler des projets dans des conteneurs locaux pour avoir facilement accès à certains outils et à certains services sans devoir tout installé sur une machine de développement. Docker est une nouvelle alternative aux machines virtuelles, mais qui est beaucoup plus performante, plus simple à utiliser et plus facilement réutilisable. Docker permet de régler des problèmes de configuration en créant une seule application qui peut être utilisée partout et qui ne dépend pas d’outils externes à son conteneur. </p>
                <u>Versions: </u>
                <ul>
                    <li> Node.js: 6.6.0 </li>
                    <li> Npm: 3.10.7 </li>
                    <li> Yeoman: 1.8.5 </li>
                    <li> Generator-angular: 0.15.1</li>
                    <li> Angular: 1.5.8 </li>
                    <li> Bower: 1.7.9 </li>
                    <li> Grunt-cli: 1.2.0 </li>
                    <li> Grunt: 0.4.5 </li>
                    <li> Karma: 1.3.0 </li>
                    <li> Jasmine: 2.5.2 </li>
                    <li> D3: 3.5.17 </li>
                    <li> D3-tip: 0.7.1 </li>
                    <li> Heroku-cli: 5.4.8 </li>
                    <li> Heroku toolbelt: 3.43.13 </li>
                    <li> Docker: 1.12.2 </li>
                </ul>
            </div>
            <br>
            <div id="propositionLimites">
                <h4> Limites </h4>
                <p> Une de nos plus grosses limites dans ce projet est la question de performance. En effet, notre projet fonctionne, mais sur les ordinateurs moins puissants, on peut remarquer que le chargement de la page prend quelques secondes et qu’il y a un certain décalage lorsque l’on tente de faire un zoom dans le graphique.  </p>
                <p> La raison de ce décalage est dû principalement au grand nombre de données que nous avons dans notre graphique. En effet, avec les données de test que nous avons recueillies nous avons près de 200 points dans notre graphique. Chaque fois qu’un utilisateur fait un zoom dans le graphique, la position de chacun de ces 200 points doit être mise à jour. Puisqu’il est facilement possible de forcer plusieurs zooms un à la suite de l’autre (ce qui est voulu pour une interaction utilisateur plus naturelle), il est possible de demander très rapidement beaucoup de ressources pour l’exécution du script de la mise à jour des points. </p>
                <p> Si l’on aurait moins de points dans notre graphique, il y aurait certainement une forte hausse des performances. Par contre, puisque nous sommes limités dans le temps, nous n’avons pas trouvé de méthode d’augmenter la performance puisque nous voulions mettre l’accent sur les fonctionnalités et non sur les performances. </p>
                <p> Nous avons tout de même réussi à aller plus loin que nous aurions cru au départ. En effet, nous avions le sentiment qu’il nous serait impossible d’utiliser des données venant d’un contexte réel, mais grâce au site web Champion.gg, nous avons pu faciliter collecter des données venant du jeu en ligne League of Legends. Ce site web nous a offert une base de données ayant toutes les informations que nous souhaitions. Il nous a fallu simplement aller repeupler sa base de donnée sur notre propre poste et grâce à cela nous avons eu accès à toutes les informations pour faire notre graphique. </p>
                <p> Aussi, nous avions cru ne pas avoir le temps d’ajouter certaines fonctionnalités à notre graphique comme le zoom ou le filtre. Nous avons réussi à mettre en place ces fonctionnalités ce qui fait en sorte que notre graphique de démonstration est plus complet et plus représentatif de qu’un vrai graphique de ce type de donnée devrait ressembler. </p>
                <p> Il reste tout de même certaines fonctionnalités que nous aimerions implémenter. C’est-à-dire pouvoir changer quel type de donnée est géré par chacun des axes de façon à ce que les utilisateurs puissent comparer n’importe quel statistiques ensemble. </p>
                <p> Nos limites réelles en ce moment même sont le temps et les performances. Si nous avions plus de temps nous pourrions nous créer une composante plus complète pour rajouter les images facilement et rajouter d’autres fonctionnalités. Aussi les performances nous limitent, car on ne peut pas faire un graphique avec encore plus de données si l’on ne veut pas avoir de problèmes pour exécuter l’application. </p>
            </div>
        </div>
        <br>
        <div id="acquisitionConnaissances">
            <h3> Acquisition des connaissances </h3>
            <p> L’acquisition des connaissances s’est surtout faite sur la compréhension du fonctionnement de la librairie graphique D3. Par conséquent, nous n’allons pas expliquer le fonctionnement du cadriciel Angular, ni de toutes autres technologies utilisées pour réaliser notre projet. L’objectif principal du projet était de mettre des images dans un graphique pour simplifier la compréhension de celui-ci. Pour arriver à ce but, il n’aurait pas été nécessaire d’utiliser autre chose que D3. Les autres technologies servent à nous simplifier la tâche dans la conception de notre application, par conséquent il n’est pas nécessaire de décrire les connaissances acquises par celles-ci puisqu’elle n’aide pas à atteindre notre but.</p>
            <p> La conception du graphique se fait en plusieurs étapes: La définition du graphique (ses marges, l’endroit qu’il prend dans la page, les axes, etc.), le tip (permet de voir le point exact des données en passant la souris par-dessus celles-ci), l'insertion des images, la catégorisation par couleurs (selon des groupes logiques) et le zoom. </p>
            <br>
            <div id="acquisitionGraphique">
                <h4> Base du graphique </h4>
                <p> Pour créer le graphique, on commence par se créer une base avec les dimensions que l’on souhaite avoir. On définit la grandeur et la largeur en soustrayant les marges pour laisser de la place aux axes. La grandeur et la largeur serviront seulement à définir le rectangle où seront placées les données. </p>
                <pre>
                    <code>
                        var config = {
                            chart_dimension : {
                                width : 960,
                                height : 500
                            },
                            margin : {
                                top: 20,
                                right: 20,
                                bottom: 30,
                                left: 30
                            }
                        };

                        var margin = config.margin,
                            width = config.chart_dimension.width - margin.left - margin.right,
                            height = config.chart_dimension.height - margin.top - margin.bottom;
                     </code>
                </pre>
                <p> Par la suite, on place le graphique dans une balise svg. Une balise svg permettra de faire le graphique. On ajoute à notre svg une viewbox. Celle-ci permettra de faire en sorte que le graphique ne dépasse jamais les dimensions maximales. Sans celle-ci, si l’on zoom dans la page, le graphique dépassera dans les autres colonnes. Finalement, on ajoute un élément qui prendra la place réelle du graphique (sans les axes) où seront placées les données. Pour le mettre à sa place, on fait une translation pour le placer dans le coin droit pour garder les axes dans le bas et à gauche. </p>
                <pre>
                    <code>
                        var svg = d3.select("#chart").append("svg")
                            .attr("viewBox", "0 0 " + (config.chart_dimension.width) + " " + (config.chart_dimension.height))
                            .append("g")
                            .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
                     </code>
                </pre>
                <p> Nous sommes maintenant prêts à gérer les données du graphique. Pour ce faire, il faudra mettre tout le code par rapport aux données (les limites des axes et des points) dans une fonction qui utilisera un fichier json pour avoir ses données. </p>
                <pre>
                    <code>
                        d3.json("data.json", function (error, data) {
                            if (error) throw error;

                        });
                    </code>
                </pre>
                <p> Dans cette fonction, on commence par définir les limites par rapport à nos données. En effet, si nos données vont de 30 à 70%, il est préférable de ne pas montrer les pourcentages entre 0 et 30 ainsi qu’entre 70 et 100%. Cela fait en sorte que notre graphique est plus claire et que nos données sont mieux puisqu’avec un domaine plus grand elles sont plus séparées les unes des autres. Premièrement, il faut trouver les points en X et en Y minimum et maximum. </p>
                <pre>
                    <code>
                        var xMin = d3.min(data, function (d) {
                            return d.general.winPercent;
                        });

                        var xMax = d3.max(data, function (d) {
                            return d.general.winPercent;
                        });

                        var yMin = d3.min(data, function (d) {
                            return d.general.playPercent;
                        });

                        var yMax = d3.max(data, function (d) {
                            return d.general.playPercent;
                        });
                    </code>
                </pre>
                <p> Puis, il faut définir nos scales qui permettront de définir quel espace nos axes (range) prendront et sur quel domaine (domain). L’espace est défini par le grandeur pris par notre rectangle de données et le domaine est défini par la différence entre les points minimum et maximum de x et de y respectivement. Par contre, puisque l’on ne souhaite pas que nos points soient directement sur l’axe, il faut leur laisser une marge. Dans notre cas, puisque l’on souhaite avoir des images et que ceux-ci ne touchent pas les axes, il faut laisser une assez grande marge. Ce qui nous amène avec le résultat suivant. </p>
                <pre>
                    <code>
                        var config = {
                            (…)
                            domain_margin : 2,
                        };

                        (…)

                        var x = d3.scale.linear()
                            .range([0, width])
                            .domain([ xMin - config.domain_margin, xMax + config.domain_margin]);

                        var y = d3.scale.linear()
                            .range([height, 0])
                            .domain([ yMin - config.domain_margin, yMax + config.domain_margin]);
                    </code>
                </pre>
                <p> Ensuite, il faut mettre ces informations dans l’axe. L’axe appelle nos scales créés précédemment. C’est dans l’axe qu’on définit comment notre grillage sera fait. La valeur de «ticks» nous donne le nombre de lignes qu’il y aura dans la grille. Aussi, la valeur de tickPadding nous donne la distance en pixels qu’il y aura entre l’axe et le nombre donnant la valeur à notre point X. </p>
                <pre>
                    <code>
                        var xAxis = d3.svg.axis()
                            .scale(x)
                            .orient("bottom")
                            .ticks(20)
                            .innerTickSize(-height)
                            .outerTickSize(0)
                            .tickPadding(10);

                        var yAxis = d3.svg.axis()
                            .scale(y)
                            .orient("left")
                            .ticks(15)
                            .innerTickSize(-width)
                            .outerTickSize(0)
                            .tickPadding(10);
                    </code>
                </pre>
                <p> Pour compléter l’axe, il suffit de rajouter celle-ci à notre svg précédemment créé. On leur donne un style CSS et puis on appelle notre axe pour qu’il soit ajouté. Finalement, on peut rajouter un texte qui identifie notre axe.  </p>
                <pre>
                    <code>
                        svg.append("g")
                            .attr("class", "x axis")
                            .attr("transform", "translate(0," + height + ")")
                            .call(xAxis)
                            .append("text")
                            .attr("class", "label")
                            .attr("x", width)
                            .attr("y", -6)
                            .style("text-anchor", "end")
                            .text("Win (%)");

                        svg.append("g")
                            .attr("class", "y axis")
                            .call(yAxis)
                            .append("text")
                            .attr("class", "label")
                            .attr("transform", "rotate(-90)")
                            .attr("y", 6)
                            .attr("dy", ".71em")
                            .style("text-anchor", "end")
                            .text("Play (%)");
                    </code>
                </pre>
                <p> Il ne faut pas oublier de créer le CSS en lien avec nos éléments pour s’assurer que nos axes apparaissent correctement : </p>
                <pre>
                    <code>
                        .grid .tick {
                          stroke: lightgrey;
                          opacity: 0.7;
                        }
                        .grid path {
                          stroke-width: 0;
                        }

                        .axis path,
                        .axis line{
                          fill: none;
                          stroke: black;
                        }

                        .tick text{
                          font-size: 12px;
                        }

                        .tick line{
                          opacity: 0.2;
                        }
                    </code>
                </pre>
                <p> Pour compléter la base de notre graphique, il reste uniquement à placer nos données. Cette dernière partie est assez simple. Il suffit d’ajouter un élément g dans lequel on sélectionne nos données et auxquelles on ajoute des cercles avec le rayon voulu. Pour faire placer nos point au bon endroit du graphique, on doit appeler une fonction qui fait la translation de chacun de nos points selon la donnée qu’on leur donne. </p>
                <pre>
                    <code>
                        svg.append("g")
                            .selectAll(".dot")
                            .data(data)
                            .enter().append("circle")
                            .attr("r", 2)
                            .attr("transform", transform);

                        function transform(d) {
                            return "translate(" + x(d.general.winPercent) +"," + y(d.general.playPercent)+")";
                        }
                    </code>
                </pre>
                <p> À la fin de cette expérimentation, on devrait avoir un graphique avec des axes, une grille et avec des points liés à nos données. </p>
            </div>
            <br>
            <div id="acquisitionTip">
                <h4> Tip </h4>
                <p>  Le tip est la fonctionnalité qui nous permet de voir un rectangle nous donnant des détails sur notre élément de notre graphique (dans notre cas un point) lorsque l’on passe la souris par-dessus celui-ci. Grâce à la librairie D3-tip, faire afficher un tip est quelque chose d’assez simple. En effet, il suffit de faire un appel à la fonction de la librairie et d’injecter notre style et le html que l’on souhaite faire apparaître lorsque l’on passe la souris par-dessus un point. </p>
                <pre>
                    <code>
                        var tip = d3.tip()
                            .attr('class', 'd3-tip')
                            .offset([-10, 0])
                            .html(function (d) {
                                return "<strong> " + d.key + " " + d.role + " </strong>" +
                                    "<br>" +
                                    "<strong>Win %:</strong> <span>" + d.general.winPercent + "</span> " +
                                    "<br>" +
                                    "<strong>Play %:</strong> <span>" + d.general.playPercent + "</span> ";
                            });
                    </code>
                </pre>
                <p> Du CSS nous permettra de faire le style que l’on souhaite avoir pour la boîte dans laquelle nos informations seront inscrites.  </p>
                <pre>
                    <code>
                        .d3-tip {
                          line-height: 1;
                          font-weight: bold;
                          padding: 12px;
                          background: rgba(0, 0, 0, 0.8);
                          color: #fff;
                          border-radius: 2px;
                        }

                        /* Creates a small triangle extender for the tooltip */
                        .d3-tip:after {
                          box-sizing: border-box;
                          display: inline;
                          font-size: 10px;
                          width: 100%;
                          line-height: 1;
                          color: rgba(0, 0, 0, 0.8);
                          content: "\25BC";
                          position: absolute;
                          text-align: center;
                        }

                        /* Style northward tooltips differently */
                        .d3-tip.n:after {
                          margin: -1px 0 0 0;
                          top: 100%;
                          left: 0;
                        }
                    </code>
                </pre>
                <p>  Par la suite, il suffit de faire les appels nécessaires pour que notre tip s’affiche lorsque l’on passe la souris par-dessus un point et pour que le tip disparaisse lorsqu’on éloigne la souris. Il faut donc faire un appel et une modification à la façon dont on crée nos points pour ajouter cette fonctionnalité. </p>
                <pre>
                    <code>
                        svg.call(tip);

                        svg.append("g")
                            .selectAll(".dot")
                            .data(data)
                            .enter().append("circle")
                            .attr("r", 2)
                            .attr("transform", transform)
                            .on('mouseover', tip.show)
                            .on('mouseout', tip.hide);
                    </code>
                </pre>
                <p>  Avec ces quelques étapes, nous avons désormais une façon plus précise de savoir ce que chaque point signifie et où exactement il est placé.  </p>
            </div>
            <br>
            <div id="acquisitionImages">
                <h4> Insertion des images </h4>
                <p> Pour pouvoir insérer les images, il faut commencer par se créer un pattern pour chaque point de notre graphique. Ce pattern nous permettra d’insérer une image qui représentera la donnée que l’on souhaite présenter. Puisque chacun de ces patterns à un id unique il sera possible plus tard de les déplacer dans le point correspondant. Il faut aussi s’assurer que la taille de notre pattern est presque nulle puisqu’on ne veut pas que nos images apparaissent avant qu’elles soient déplacées dans leur point. Il est nécessaire de se créer un pattern, car l’élément circle ne peut pas se remplir avec une image directement. </p>
                <pre>
                    <code>
                        var config = {
                            avatar_size : 50,
                            patchVersion : "6.20.1"
                            (…)
                        };

                        var defs = svg.append("defs").attr("id", "imgdefs");

                        data.forEach(function (d) {
                            var champPattern = defs.append("pattern")
                                .attr("id", "champ_avatar_" + d.key + d.role)
                                .attr("height", 1)
                                .attr("width", 1)
                                .attr("x", "0")
                                .attr("y", "0")

                            champPattern.append("image")
                                .attr("x", 0)
                                .attr("y", 0)
                                .attr("height", config.avatar_size)
                                .attr("width", config.avatar_size)
                                .attr("xlink:href", "//ddragon.leagueoflegends.com/cdn/" + config.patchVersion + "/img/champion/" + d.key + ".png");
                        });
                    </code>
                </pre>
                <p> Il reste maintenant à lier ces images à notre point correspondant. Pour arriver à ce résultat, il suffit de modifier certaines propriétés de l’étape à laquelle on ajoute nos points dans le graphique. Les cercles qui représentent nos points devront donc être plus grands (pour bien montrer l’image) et il faudra les remplir avec notre image. L’attribut r permet de définir le rayon de notre cercle et le style fill nous permet de donner le lien vers l’id de notre image. </p>
                <pre>
                    <code>
                        svg.append("g")
                            .selectAll(".dot")
                            .data(data)
                            .enter().append("circle")
                            .attr("r", config.avatar_size/2)
                            .attr("transform", transform)
                            .style("fill", function (d) {
                                return "url(#champ_avatar_" + d.key + d.role + ")";
                            })
                            .on('mouseover', tip.show)
                            .on('mouseout', tip.hide);
                    </code>
                </pre>
                <p> Après cette étape, toutes nos données devraient apparaître avec l’image qui les lie. Il est absolument nécessaire lier nos données avec un pattern, car un cercle ne peut pas être rempli par un pattern. Cela rend la démarche plus compliquée, mais nettement plus efficace. </p>
            </div>
            <br>
            <div id="acquisitionCategorisation">
                <h4> Catégorisation </h4>
                <p> Pour catégoriser facilement nos données, nous avons décidé d’utiliser le principe de couleur offert par D3. Ce principe fait en sorte que lorsque l’on envoie une même information (dans notre cas le rôle de notre donnée), D3 redonne toujours la même valeur pour toutes les données ayant la même information. </p>
                <pre>
                    <code>
                        var color = d3.scale.category10();
                    </code>
                </pre>
                <p> Par la suite, il reste à appliquer cette couleur sur nos données pour bien les catégoriser. Puisque nous utilisons des cercles, il faut simplement déclarer quel couleur prendra le contour. On change donc le style du stroke et on lui donne comme valeur notre banque de couleur qui prend en paramètre l’information par laquelle on veut catégoriser nos éléments. Pour terminer cette section, il faut aussi modifier la classe de nos points pour pouvoir par la suite faire des modifications par catégories. </p>
                <pre>
                    <code>
                        svg.append("g").attr("clip-path", "url(#clip)")
                            .selectAll(".dot")
                            .data(data)
                            .enter().append("circle")
                            .attr("id", "chartPoint")
                            .attr("r", config.avatar_size/2)
                            .attr("id", "chartPoint")
                            .attr("transform", transform)
                            .style("fill", function (d) {
                                return "url(#champ_avatar_" + d.key + d.role + ")";
                            })
                            .style("stroke", function(d){
                                return color(d.role);
                            })
                            .style("stroke-width", "2.5")
                            .attr("class", function(d){
                                return d.role;
                            })
                            .on('mouseover', tip.show)
                            .on('mouseout', tip.hide);
                    </code>
                </pre>
                <p> Pour clarifier ce que signifie chaque couleur, nous aurions pu créer une légende simple, mais dans le contexte de notre application, nous voulions pouvoir cacher certaines catégories de données si nécessaire. Pour cette raison, nous avons décidé de nous créer des checkbox qui nous permettront de cacher nos données lorsque celles-ci seront décochées. </p>
                <pre>
                    <xmp>
                        <div id="roleCheck">
                            <div class="checkbox roleBox">
                                <label><input type="checkbox" checked value="" ng-click="changeVisibility('Top')">Top</label>
                            </div>
                            <div class="checkbox roleBox">
                                <label><input type="checkbox" checked value="" ng-click="changeVisibility('Jungle')">Jungle</label>
                            </div>
                            <div class="checkbox roleBox">
                                <label><input type="checkbox" checked value="" ng-click="changeVisibility('Middle')">Middle</label>
                            </div>
                            <div class="checkbox roleBox">
                                <label><input type="checkbox" checked value="" ng-click="changeVisibility('ADC')">ADC</label>
                            </div>
                            <div class="checkbox roleBox">
                                <label><input type="checkbox" checked value="" ng-click="changeVisibility('Support')">Support</label>
                            </div>
                        </div>
                    </xmp>
                </pre>
                <p> Par la suite, il nous reste à changer la couleur de nos checkbox en fonction des couleurs précédemment créées. D3 nous permet de sélectionner tous les éléments de la même classe et d’y lier le domaine de la couleur. De cette façon, le premier élément ayant cette classe aura la première couleur du domaine, le deuxième aura la deuxième couleur et ainsi de suite. </p>
                <pre>
                    <code>
                        var changeBoxColor = function(color){
                            d3.selectAll(".roleBox")
                                .data(color.domain())
                                .style("color", color);
                        };
                    </code>
                </pre>
                <p> Puis, pour pouvoir changer la visibilité de nos points selon la catégorie, on utilise un peu de JQuery. Cette simple fonction prendra tous les éléments ayant la classe passée en paramètre pour changer leur visibilité. </p>
                <pre>
                    <code>
                        $scope.changeVisibility = function(className){
                            $('.' + className).toggle();
                        };
                    </code>
                </pre>
                <p> À la fin de cette section, tous nos points devraient avoir un contour de couleur lié à leur catégorie d’information et il devrait être possible de changer leur visibilité en décochant au besoin la case reliée à leur catégorie. </p>
            </div>
            <br>
            <div id="acquisitionZoom">
                <h4> Zoom </h4>
                <p> Pour commencer à utiliser le zoom, il faut commencer par décrire le comportement que l’on souhaite avoir dans celui-ci. En premier lieu, il faut décrire le domaine disponible sur lequel on veut pouvoir faire du drag and drop. Celui-ci devrait se limiter au maximum à la largeur de notre graphique ou à notre domaine.  </p>
                <p> Ensuite, il faut faire toute la logique pour mettre à jour nos axes et nos points lorsque l’on zoom. Pour mettre à jour nos axes, il faut sélectionner chacun des axes que l’on souhaite mettre à jour et rappeler la fonction créée plus tôt qui permet de construire nos axes. Aussi, il faut sélectionner tous nos points du graphique et rappeler la fonction qui nous permet de faire la translation des points. </p>
                <pre>
                    <code>
                        function zoomed() {
                            var trans = zoom.translate(),
                                scale = zoom.scale();

                            //limit drag
                            var tx = Math.min(0, Math.max(width * (1 - scale), trans[0]));
                            var ty = Math.min(0, Math.max(height * (1 - scale), trans[1]));

                            zoom.translate([tx, ty]);

                            svg.select(".x.axis").call(xAxis);
                            svg.select(".y.axis").call(yAxis);
                            svg.selectAll("#chartPoint")
                                .attr("transform", transform);
                        }
                    </code>
                </pre>
                    <p> Pour pouvoir faire en sorte que cette fonction soit appelé à chaque fois que l’on zoom ou que l’on fasse un drag and drop, il faut lier cette méthode avec un des comportements de D3. La fonction de zoom nous dit quoi faire lorsqu’un zoom est fait. C’est aussi dans cette section qu’il est possible de limiter à quel point l’on souhaite zoomer dans le graphique. Après avoir lié le comportement avec nos axes, il suffit de faire un appel de ce comportement avec notre élément graphique pour faire en sorte que chaque changement apporte ses modifications. </p>
                    <pre>
                    <code>
                        var config = {
                            (…)
                            max_zoom : 10
                        };

                        var zoom = d3.behavior.zoom()
                            .x(x)
                            .y(y)
                            .scaleExtent([1, config.max_zoom])
                            .on("zoom", zoomed);

                        svg.call(zoom);
                    </code>
                </pre>
                    <p> Le comportement du zoom marche désormais, mais il reste tout de même quelques problèmes. Le premier problème est que la section dans laquelle on peut zoomer n’a jamais été défini correctement puisque le zoom fonctionne seulement sur les éléments qui ont été ajouté au svg. Jusqu’à maintenant, les seuls sections qui ont été ajouté au svg sont nos axes et les points du graphique. Donc, puisque les axes ne permettent pas de faire un zoom, seulement les points du graphique nous permettent de zoomer. Pour régler ce problème, il suffit de définir un rectangle qui prendra la zone de graphique. Celui-ci fera en sorte de créer notre boîte sur laquelle il est possible de zoomer. </p>
                    <pre>
                    <code>
                        //appends a rectangle to the svg to make the zoom work
                        var rect = svg.append("svg:rect")
                            .attr("width", width)
                            .attr("height", height)
                            .style("fill", "none")
                            .style("pointer-events", "all");
                    </code>
                </pre>
                    <p> L’autre problème qu’il nous reste à corriger est que la section où les points peuvent être placés est encore limité à l’ensemble du graphique. Ceci n’était pas un problème initialement puisque les points ne pouvaient pas faire de translation, mais désormais si l’on tente de faire un zoom on peut remarquer que les points peuvent aller par-dessus les axes. Pour corriger ce problème, il faut ajouter un élément de clipPath. Celui-ci défini l’endroit où les objets peuvent être placé ce qui limitera l’aire où les points peuvent aller à notre coin du graphique. Il suffit de créer cet élément et de par la suite le lier avec nos points pour limiter l’aire d’action de nos points. </p>
                    <pre>
                    <code>
                        //appends a clip to the svg to make sure the points are restricted to the chart rectangle and not the svg
                        var clip = svg.append("defs").append("svg:clipPath")
                            .attr("id", "clip")
                            .append("svg:rect")
                            .attr("id", "clip-rect")
                            .attr("x", "0")
                            .attr("y", "0")
                            .attr('width', width)
                            .attr('height', height);

                        //Place Data
                        svg.append("g").attr("clip-path", "url(#clip)")
                            .selectAll(".dot")
                            .data(data)
                            .enter().append("circle")
                            .attr("id", "chartPoint")
                            .attr("r", config.avatar_size/2)
                            .attr("transform", transform)
                            .style("fill", function (d) {
                                return "url(#champ_avatar_" + d.key + d.role + ")";
                            })
                            .style("stroke", function(d){
                                return color(d.role);
                            })
                            .style("stroke-width", "2.5")
                            .attr("class", function(d){
                                return d.role;
                            })
                            .on('mouseover', tip.show)
                            .on('mouseout', tip.hide);
                    </code>
                </pre>
                <p> Après cette étape, le graphique devrait être désormais complet. On devrait être capable de zoomer, de catégoriser et de bien voir où sont tous nos points sur le graphique. </p>
            </div>
        </div>
        <br>
        <div id="demarcheExperimentale">
            <h3> Démarche expérimentale </h3>
            <p> Pour faire notre application, nous avons choisi d’utiliser Angular. Quoique nous n’avons pas beaucoup utilisé les outils d’Angular pour la gestion entre le DOM et le JavaScript, nous avons tout de même utilisé l’architecture propre à Angular. Nous avons utilisé un générateur Yeoman pour nous créer notre base de projet et ainsi pouvoir passer le plus de temps possible sur le développement de l’application. </p>
            <p> Le problème que nous voulions régler était l’impossibilité de représenter des images dans un graphique. Pour régler ce problème, nous avons dû premièrement trouver une librairie JavaScript qui nous permettrait de faire nos graphiques. </p>
            <p> Nous avons choisi d’utiliser D3. Celui-ci offre plusieurs avantages comparés à d’autres librairies graphiques. Un de ses avantages principaux est qu’il permet de faire plus de choses. En effet, à la base D3 existe pour manipuler le DOM, donc il n’est pas limité à créer des graphiques. Autrement dit, avec cette librairie il est plus facile de manipuler les images. En plus, D3 fonctionne directement avec le HTML, le SVG et le CSS ce qui fait en sorte qu’il est plus facilement compatible avec tous les navigateurs. </p>
            <p> D3 offre la possibilité de créer toutes sortes de graphiques. Par exemple, il est possible de faire des graphes, des nuages de points, des diagrammes à bandes, des diagrammes circulaires, etc. </p>
            <p> Dans notre application, nous avons utilisé un graphique de nuage de points. Pour faire ce nuage de points, nous avons dû utiliser les outils de base de D3 pour faire un graphique. C’est-à-dire d3-scale qui permet de gérer le domaine du graphique, d3-axis qui permet de gérer les axes du graphique et aussi l’outil de d3 qui permet de lier les points avec les données.  </p>
            <p> Par la suite, pour rendre notre graphique plus complet, nous avons rajouté d3-zoom et d3-tip. </p>
            <p> Bien sûr le but du projet était de mettre des images dans un graphique, alors nous avons dû trouver une façon de le faire avec la librairie D3. Le problème qui se trouve avec la gestion des images est que pour pouvoir insérer une image dans le graphique, il faut préalablement l’insérer dans le DOM. En effet, D3 ne fait que manipuler le DOM. Pour lier une image à un endroit dans le graphique, il faut que l’image soit préalablement là. </p>
            <p> Pour régler ce problème, nous devons absolument insérer dans le DOM des patterns contenant l’image que nous voulons ajouter et qui possède l’identifiant qui peut les relier à l’image. Par la suite, lorsque l’on place nos points dans le graphique, on peut se créer des cercles que l’on peut remplir avec l’identifiant nécessaire. </p>
            <pre>
            <code>
                <span class="text-info">var</span> loadImagePatterns = <span class="text-info">function</span>(svg, data, config){
                    <span class="text-info">var</span> <span class="text-primary">defs</span> = svg.append(<span class="text-success">"defs"</span>).attr(<span class="text-success">"id"</span>, <span class="text-success">"imgdefs"</span>);

                    data.forEach(<span class="text-info">function</span> (d) {
                        <b>//load les patterns avec l’id</b>
                        <span class="text-info">var</span> <span class="text-primary">champPattern</span> = <span class="text-primary">defs</span>.append(<span class="text-success">"pattern"</span>)
                        .attr(<span class="text-success">"id"</span>, <span class="text-success">"champ_avatar_"</span> + d.key + d.role)
                        .attr(<span class="text-success">"x"</span>, <span class="text-success">"0"</span>)
                        .attr(<span class="text-success">"y"</span>, <span class="text-success">"0"</span>);

                        <b>//rajoute les images avec le lien vers celle-ci</b>
                        <span class="text-primary">champPattern</span>.append(<span class="text-success">"image"</span>)
                            .attr(<span class="text-success">"height"</span>, config.avatar_size)
                            .attr(<span class="text-success">"width"</span>, config.avatar_size)
                            .attr(<span class="text-success">"xlink:href"</span>, <span class="text-success">"//ddragon.leagueoflegends.com/cdn/"</span>+
                            config.patchVersion+ <span class="text-success">"/img/champion/"</span> + d.key + <span class="text-success">".png"</span>);
                            });
                    };

                    <b>//Place Data</b>
                    <span class="text-primary">svg</span>.append(<span class="text-success">"g"</span>)
                        .selectAll(<span class="text-success">".dot"</span>)
                        .data(data)
                        .enter().append(<span class="text-success">"circle"</span>)
                        .attr(<span class="text-success">"r"</span>, <span class="text-primary">config</span>.avatar_size/2)
                        .style(<span class="text-success">"fill"</span>, <span class="text-info">function</span> (d) {
                        //remplis le cercle avec l’id créé plus tôt
                        <span class="text-info">return</span> <span class="text-success">"url(#champ_avatar_"</span> + d.key + d.role + ")";
                });
            </code>
            </pre>
            <p> Les outils d’expérimentation utilisés ont donc réussi à régler notre problème, mais la solution n’est pas optimale. En effet, faire toutes ces opérations n’est pas très efficace lorsque la quantité de données est élevée. </p>
            <p> Avant de commencer le projet, nous nous attendions à arriver à ce point et nous n’avions pas mis la performance comme une de nos priorités alors il est possible de dire avec confiance que les outils d’expérimentation ont réussi à régler notre problématique. </p>
            <p> Nos outils sont capables de bien représenter les données, ils nous donnent de nouveaux outils flexibles pour faire de la représentation de données dans le futur, ils ont permis de régler notre problème qui était de représenter des images dans un graphique et nous sommes arrivés au point auquel nous nous attendions. </p>
            <p> Au départ du projet, nous avions beaucoup d’incertitude par rapport aux outils que nous devrions utiliser. Nous ne savions pas si les outils que nous voulions utiliser étaient adéquats. Nous avions préalablement choisi d’utiliser le framework React, mais au cours de l’expérimentation, celui-ci s’est avéré à nous causer plus de problèmes alors nous avons décidé de l’abandonner pour plutôt utiliser Angular. </p>
            <p> Une autre de nos incertitudes était pour savoir quelle librairie graphique nous pourrions utiliser. Bien sûr, cette incertitude a été réglée, car D3 réglait tous nos problèmes par rapport à la librairie graphique. </p>
            <p> Il reste tout de même certaines incertitudes par rapport au projet. Premièrement, nous nous questionnons sur notre façon de gérer nos données. En effet, notre façon fonctionne, mais avec celle-ci nous restons dépendants d’un autre projet et si jamais celui-ci arrêterait, notre projet n’avancerait plus aussi bien. </p>
            <p> Aussi, nous ne savons pas comment pour l’instant nous pouvons augmenter les performances de l’application. Il est clair que nous devons créer une composante d3 pour mieux gérer la façon dont nous modifions nos images, mais pour l’instant nous ne savons pas encore quelle serait la meilleure façon de procéder. </p>
            <p> Au début du projet, nous voulions simplement créer une composante nous permettant de mettre les images dans notre graphique, mais au cours de la progression du projet nous avons changé un peu nos objectifs pour avoir un graphique plus complet. C’est-à-dire un graphique avec des données réelles et pouvant zoomer ainsi que de passer la souris pour voir les données exactes d’un point. Nous n’avons pas de composante, mais nous avons maintenant les connaissances pour pouvoir mettre des images dans un graphique. </p>
            <p> Notre expérimentation ressemble beaucoup à ce que nous voulions faire, mais avec un plus grand accent sur le visuel et un moins grand accent sur les composantes. </p>
        </div>
        <br>
        <div id="difficultes">
            <h3> Difficultés </h3>
            <p> La plupart des difficultés rencontrées au cours du projet ont un lien avec les technologies entourant notre application graphique. </p>
            <p> En effet, au départ du projet nous souhaitions utiliser le cadriciel JavaScript React qui nous semblait être un bon choix pour manipuler nos éléments graphiques. Puisque nous ne connaissions pas trop l’architecture sur laquelle nous devrions construire notre application avec React, nous avons tenté d’utiliser un générateur Yeoman pour nous construire notre application. </p>
            <p> Malheureusement, il y avait beaucoup de problèmes pour faire fonctionner l’application générée. En effet, certaines composantes avaient des problèmes de compatibilité avec l’application générée. Par exemple, la librairie graphique React-D3 ne voulait pas fonctionner avec ce générateur.  </p>
            <p> Après beaucoup de tentatives, nous avons trouvé des informations nous signifiant que le projet fonctionnait mieux sur un système Linux, alors nous avons décidé d’exporter notre application vers un système Ubuntu. Malheureusement, nous avons les mêmes problèmes sur un système Linux.  </p>
            <p> Puisque nous ne voulions pas perdre trop de temps de développement à tenter de trouver un cadriciel qui fonctionnerait bien pour nos besoins, nous avons décidé de retourner vers un cadriciel que nous connaissions bien et que nous savions qui fonctionnerait bien sus nos besoins. </p>
            <p> Un des autres problèmes que nous avons eu est que nous ne savions pas combien bien gérer les dépendances du projet. En effet, au départ de notre projet, nous gérions nos dépendances seulement avec des balises scripts qui allaient chercher le script en ligne. Ceci posait un problème, car si jamais les sources de ses scripts disparaissaient, notre projet ne fonctionnerait plus. Aussi, cela faisait en sorte que nous devions gérer chacune des dépendances et les rajouter manuellement à chaque fois que nous en ajoutions une, ce qui deviendrait problématique plus le projet grandirait. </p>
            <p> Pour régler ce problème, nous avons décidé d’utiliser Bower. Ce gestionnaire de dépendances nous a permis d’aller rechercher directement les sources dont nous avions besoin et de mieux gérer les versions des dépendances de notre projet. En plus, le dernier générateur que nous avons utilisé venait directement avec Bower ce qui nous a simplifié le travail dans la configuration du gestionnaire. </p>
            <p> Les autres problèmes majeurs que nous avons eus sont en lien avec l’application graphique elle-même. Puisque nous ne connaissions pas le fonctionnement de D3, nous avons eu beaucoup de problèmes à comprendre la logique de certains de nos problèmes. Par exemple, il a fallu beaucoup de temps pour bien faire fonctionner le zoom puisque la fonctionnalité demande la création et la liaison de plusieurs éléments. Voici une liste des problèmes que nous avons eus durant la création du zoom : les axes qui ne se synchronisent pas, les points qui ne se synchronisent pas, le zoom pouvant être trop large, le drag and drop qui nous permet d’aller beaucoup trop loin, l’incapacité de zoomer dans le graphique mis à part quand la souris est par-dessus un des points, les points qui passent par-dessus les axes quand on fait un zoom, etc. Autrement dit, le zoom était une des plus grandes difficultés dans la partie graphique de l’application. </p>
            <p> Néanmoins, malgré tous ces problèmes, nous avons tout de même bien avancé dans le temps par apport à notre projet et nous pouvons dire que nous n’avons pas eu de difficulté insurmontable jusqu’à maintenant. </p>
        </div>
        <br>
        <div id="analyseResultats">
            <h3> Analyse des résultats </h3>
            <p> Notre but initial était de créer une application de graphique qui pourrait présenter un graphique avec des images à la place de points pour mieux représenter les données. Cette application avait pour but de donner une autre dimension à la façon de voir des données pour comprendre en un seul coup d’œil ce que chaque point représente. </p>
            <p> Notre but initial a été comblé, mais tous les buts fixés n’ont pas été répondus. À ce propos, un autre de nos buts était d’offrir un service qui permettrait d’arriver facilement au même point que nous nous étions rendus. C’est-à-dire insérer facilement des images dans un graphique. Ce but n’a pas été comblé, car nous avons mis un grand accent sur la conception d’un graphique qui serait plus plaisant à regarder et qui serait plus clair. </p>
            <p> Effectivement, sans les images dans le graphique, il est possible de voir certaines tendances se former et de bien comprendre l’information qui nous est présentée. Un des seuls effets négatifs de ne pas avoir d’images est qu’il est plus difficile d’identifier les points qui se dégagent des tendances.  </p>
            <p> Par contre, avec les images, puisque chaque point prend un espace plus grand, il est plus difficile de voir où exactement chaque point est posé. En plus, à cause des images, certains points peuvent être plus facilement cachés, car les points au-dessus de celui-ci sont plus larges et peuvent créer une agglomération qui cacherait celui-ci. Pour résoudre ce problème, il faut soit avoir un graphique plus grand (pour permettre d’avoir le même domaine sur une plus grande surface) ou il faut pouvoir zoomer dans le graphique pour dégager les points les uns des autres. </p>
            <figure class="figure">
                <img src="../images/analysis_agglomeration.png" style="width: 100%;" class="figure-img img-fluid rounded">
                <figcaption class="figure-caption text-center"> Sans zoom et avec des images, une agglomération se crée.</figcaption>
            </figure>
            <br>
            <p> Dans le contexte de notre application, nous avons décidé de prendre plus de temps pour avoir des résultats plus clair grâce à un zoom. Cela nous a permis de dégager les points les uns des autres pour mieux voir où se situe chaque point.  </p>
            <figure class="figure">
                <img src="../images/analysis_zoom.png" style="width: 100%;" class="figure-img img-fluid rounded">
                <figcaption class="figure-caption text-center"> Le zoom permet de dégager les données. </figcaption>
            </figure>
            <br>
            <p> Malheureusement, comme nous étions limités dans le temps et que la création de cette fonctionnalité importante a pris beaucoup de ressources, nous n’avons pas eu le temps de créer un service pour mettre les images avec D3.  </p>
            <p> Il nous aurait été sûrement possible de créer un service, mais cette fonctionnalité aurait été au détriment de la qualité de notre application ce qui était un coût que nous ne voulions pas nécessairement payer. Les changements d’objectifs et les résultats obtenus sont donc dus aux changements des besoins découverts durant la création de l’application. </p>
        </div>
        <br>
        <div id="conclusionRecherche">
            <h3> Conclusion de la recherche </h3>
            <p> En conclusion, les travaux effectués nous ont permis d’atteindre notre objectif principal de mettre des images dans un graphique. Par contre, nous n’avons pas été en mesure de créer un service qui nous permettrait d’offrir à d’autres personnes de rajouter directement les images dans leur propre graphique. </p>
            <p> Grâce à ce projet, nous avons acquis beaucoup de connaissances sur le fonctionnement de la librairie D3 qui est utile pour créer des applications graphiques.  Nous avons été en mesure de créer un graphique complexe et complet qui offre une autre façon de voir des résultats statistiques et qui permet de plus facilement identifier les points se dégageant des tendances. </p>
            <p> Considérant que nous n’avions aucune connaissance sur la librairie graphique D3, nous pouvons dire que nous avons fait beaucoup d’avancées par rapport à nos connaissances et nos incertitudes. En effet, la plupart de nos incertitudes étaient en lien avec notre capacité à créer l’application et par rapport aux technologies que nous devrions utiliser. Notre résultat final prouve que nos incertitudes ont été éclairées. </p>
            <p> Pour continuer le projet, nous pourrions tenter de faire un de nos objectifs de projet qui était de créer un service qui permettrait de mettre les images dans le graphique. Aussi, nous pourrions avancer encore plus notre graphique en permettant de comparer d’autres statistiques que celles que nous avons utilisé.  </p>
        </div>
        <br>
        <div id="biliographie">
            <h3> Bibliographie: </h3>
            <p> Code source du projet: <a href="https://github.com/Thuranel/ImageChart/"> https://github.com/Thuranel/ImageChart/ </a> </p>
            <p> Blog du projet: <a href="http://ejsinc.blogspot.ca/"> http://ejsinc.blogspot.ca/ </a> </p>
            <p> Node team (8 nov. 2016), «Node.js», <i> Node.js </i>, <a href="https://nodejs.org/en/"> https://nodejs.org/en/ </a> </p>
            <p> Npm team (8 nov. 2016), «Npm», <i> Npm </i>, <a href="https://www.npmjs.com/"> https://www.npmjs.com/ </a> </p>
            <p> Angular team (8 nov. 2016), «Angular», <i> Angular </i>, <a href="https://angularjs.org/"> https://angularjs.org/ </a> </p>
            <p> Yeoman team (8 nov. 2016), «Yeoman», <i> Yeoman </i>, <a href="http://yeoman.io/"> http://yeoman.io/ </a> </p>
            <p> Yeoman team (8 nov. 2016), «generator-angular», <i> Generator Angular </i>, <a href="https://github.com/yeoman/generator-angular"> https://github.com/yeoman/generator-angular </a> </p>
            <p> Bower team (8 nov. 2016), «Bower», <i> Bower </i>, <a href="https://bower.io/"> https://bower.io/ </a> </p>
            <p> Grunt team (8 nov. 2016),  «Grunt», <i> Grunt </i>, <a href="http://gruntjs.com/"> http://gruntjs.com/ </a> </p>
            <p> Karma team (8 nov. 2016), «Karma», <i> Karma runner </i>, <a href="https://karma-runner.github.io/1.0/index.html"> https://karma-runner.github.io/1.0/index.html </a> </p>
            <p> Jasmine team (8 nov. 2016), «Jasmine», <i> Jasmine </i>, <a href="https://jasmine.github.io/"> https://jasmine.github.io/ </a> </p>
            <p> D3 team (8 nov. 2016), «D3», <i> D3js </i>, <a href="https://d3js.org/"> https://d3js.org/ </a> </p>
            <p> Heroku team (8 nov. 2016), «Heroku», <i> Heroku </i>, <a href="https://www.heroku.com/home"> https://www.heroku.com/home </a> </p>
            <p> joel1st (8 nov. 2016), «Champion.gg», <i> Champion.gg </i>, <a href="http://champion.gg/"> http://champion.gg/ </a> </p>
            <p> joel1st (8 nov. 2016), «Champion.gg Github», <i> Champion web </i>, <a href="https://github.com/joel1st/championweb"> https://github.com/joel1st/championweb </a> </p>
            <p> Docker team (8 nov. 2016), «Docker», <i> Docker </i>, <a href="https://www.docker.com/"> https://www.docker.com/ </a> </p>
            <p> Riot Games (8 nov. 2016), «League of Legends», <i> League of Legends </i>, <a href="http://na.leagueoflegends.com/"> http://na.leagueoflegends.com/ </a> </p>
        </div>
        <br>
    </div>
</div>
