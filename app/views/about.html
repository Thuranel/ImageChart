<div class="row" ng-controller="AboutCtrl">
    <div id="index">
        <h2> Publication des résultats: </h2>
        <ul>
            <li>  <a ng-click="scrollTo('propositionRecherche')"> Proposition de recherche: </a>
                <ul>
                    <li> <a ng-click="scrollTo('propositionSujet')"> Sujet </a> </li>
                    <li> <a ng-click="scrollTo('propositionEnjeu')"> Enjeu </a> </li>
                    <li> <a ng-click="scrollTo('propositionExperimentation')"> Expérimentation </a> </li>
                    <li> <a ng-click="scrollTo('propositionRessources')"> Ressources </a> </li>
                    <li> <a ng-click="scrollTo('propositionLimites')"> Limites </a> </li>
                </ul>
            </li>
            <li> <a ng-click="scrollTo('acquisitionConnaissances')"> Acquisition des connaissances </a>
                <ul>
                    <li> <a ng-click="scrollTo('acquisitionGraphique')"> Base du graphique </a> </li>
                    <li> <a ng-click="scrollTo('acquisitionTip')"> Tip </a> </li>
                    <li> <a ng-click="scrollTo('acquisitionCategorisation')"> Catégorisation </a> </li>
                    <li> <a ng-click="scrollTo('acquisitionZoom')"> Zoom </a> </li>
                </ul>
            </li>
            <li> <a ng-click="scrollTo('demarcheExperimentale')"> Démarche expérimentale </a> </li>
            <li> <a ng-click="scrollTo('difficultes')"> Difficultés </a> </li>
            <li> <a ng-click="scrollTo('analyseResultats')"> Analyse des résultats </a> </li>
            <li> <a ng-click="scrollTo('conclusionRecherche')"> Conclusion de la recherche </a> </li>
            <li> <a ng-click="scrollTo('biliographie')"> Bibliographie </a> </li>
        </ul>
    </div>
    <br>
    <div class="text-justify">
        <div id="propositionRecherche">
            <h3> Proposition de recherche </h3>
            <br>
            <div id="propositionSujet">
                <h4> Sujet </h4>
                <p> Le but de cette recherche est de créer une application web permettant d’identifier des points sur un graphique grâce à des images. En effet, il existe plusieurs librairies de visualisation, mais aucune ne permet de faire cette fonction directement. Par exemple, il existe Google charts, Angular-nvD3, etc. </p>
                <p> Pouvoir ajouter des images pour identifier des points dans un graphique permet de rajouter une autre dimension à la façon de présenter des statistiques. Bien que l’utilisation de cette fonctionnalité est très spécifique à certains cas, l’ajout d’une telle fonctionnalité permet de clarifier les informations présentées dans le graphique. Par exemple, si l’on veut comparer la taille et le poids des athlètes de la NHL il serait possible de faire un graphique avec la taille des athlètes comme l’axe des X et leur poids comme l’axe des Y et en plus d’ajouter la photo des joueurs sur le point leur correspondant pour visualiser où se situe chaque joueur dans le graphique avec un seul coup d’oeil. </p>
                <p> Pour pouvoir atteindre ce but, il est nécessaire d’apprendre à utiliser une librairie de visualisation. Pour faire ce projet, nous avons décidé d’utiliser D3.js. Celui-ci offre plusieurs avantages comparés à d’autres librairies graphiques. Un de ses avantages principaux est qu’il permet de faire plus de choses. En effet, D3 permet de manipuler le DOM, donc il n’est pas limité à créer des graphiques. Autrement dit, avec cette librairie il est plus facile de manipuler les images. En plus, D3 fonctionne directement avec le HTML, le SVG et le CSS ce qui fait en sorte qu’il est plus facilement compatible avec tous les navigateurs. </p>
                <p> Au début de ce projet, D3 était une librairie nouvelle pour nous, mais nous pouvons maintenant dire que nous comprenons bien comment elle fonctionne et nous avons désormais une maîtrise suffisante pour compléter et améliorer ce projet. </p>
            </div>
            <br>
            <div id="propositionEnjeu">
                <h4> Enjeu </h4>
                <p> Ce projet de recherche est important, car il nous permet de consolider certaines connaissances sur les technologies présentes sur le web en ce moment même et de développer une façon d’approfondir le domaine d’application des statistiques.</p>
                <p> En effet, la clarté des informations est un des points les plus importants lorsque l’on présente des statistiques. Un graphique doit être complet (avoir toutes les informations nécessaires), facile à comprendre et facilement accessible.</p>
                <p> C’est ce que vise exactement notre application. Notre graphique est déjà complet, mais il présente quelques avantages que des applications graphiques n’ont pas toujours. Premièrement, il est accessible directement sur le web. Une fois que le graphique a été mis en ligne, il n’est pas nécessaire d’installer d’application pour pouvoir voir les données et l’utiliser ce qui offre un avantage par rapport à certains logiciels de visualisation qui demandent de faire des installation. En plus, ajouter des images dans notre graphique permet de rendre les informations plus faciles à comprendre. En effet, il n’est pas nécessaire de fouiller dans de la documentation pour savoir ce que chaque représente puisque l’image nous donne l’information nécessaire avec un seul coup d’oeil. </p>
                <p> Notre motivation pour faire ce projet vient du fait qu’il n’existe pas encore de façon facile de créer des graphiques où l’on peut remplacer les points par des images et ainsi clarifier les données de recherche. </p>
                <p> Une fois complété, le projet permettra de présenter des statistiques plus clairement. Par exemple, on pourrait utiliser notre méthode pour présenter des statistiques de comparaisons de joueurs de sports grâce à leur photos, de comparaisons de personnages dans un jeu vidéo grâce à leur avatar ou de comparaisons de statistiques sur l’économie de différents pays grâce à leur drapeaux. </p>
            </div>
            <br>
            <div id="propositionExperimentation">
                <h4> Expérimentation </h4>
                <p> Notre projet de recherche a été fait grâce à l’aide d’outils d’expérimentation. C’est-à-dire que nous avons tenté d’utiliser des outils pour tenter de voir le résultat concret de nos recherches dans un contexte semblable à la réalité. </p>
                <p> Pour faire cela, nous avons tenté de cibler quelles technologies pourraient nous aider à réaliser notre projet. Nous avons tenté d’utiliser ces technologies pour comprendre quel rôle chacune d’entre elles pourrait servir dans l’application et pour trouver quel serait la technologie la plus adaptée. </p>
                <p> Au début du projet, nous avions comme idée d’utiliser le cadriciel JavaScript React. Au cours de notre expérimentation, nous avons découvert que celui-ci n’était pas très adapté à nos besoins. Par conséquent, nous avons décidé de retourner vers une valeur plus sûre et que nous connaissions mieux. C’est-à-dire le cadriciel Angular. Nous avons fait ce même processus pour trouver quelle librairie graphique serait la meilleure pour présenter nos données. Au départ, nous avons tenté d’utiliser React-D3, puis Google Charts, mais aucune de ces librairies n'offrait la liberté que nous voulions avoir. C’est à ce point que nous avons trouvé D3 qui nous permettait de faire plus de choses et que nous avons approfondi nos connaissances sur cette librairie. </p>
                <p> Cette méthode d’expérimentation est bien adaptée à notre projet de recherche puisque le but initial était de créer un outil qui nous permettrait de mettre des images dans notre graphique et pour arriver à ce but nous avions besoin de premièrement trouver une librairie graphique à laquelle nous pourrions rajouter cette fonctionnalité. Par conséquent, nous étions forcés d’utiliser l’expérimentation pour trouver avec quelle librairie il serait possible de travailler pour arriver à notre but. </p>
                <p> Une des failles de notre méthode d’expérimentation serait que nous sommes dans l’incertitude si une autre librairie graphique nous aurait permis d’arriver au même ou sinon à un résultat meilleur. En effet, nous n’avons pas pu essayer toutes les librairies graphiques puisque nous étions limité dans le temps, mais le résultat que nous avons atteint démontre que notre méthode d’expérimentation était adapté. </p>
            </div>
            <br>
            <div id="propositionRessources">
                <h4> Ressources </h4>
                <p> Pour pouvoir faire ce projet, nous avons créé une application grâce à Node.js qui utilise une multitude de technologies afin de simplifier le développement et l’intégration de toutes nos composantes. </p>
                <p> <a href="https://nodejs.org/" > Node.js</a> est un runtime JavaScript créé pour faire des applications serveur facilement extensibles. Node.js est un outil de développement qui permet de faciliter la communication entre le client et le serveur en créant une connexion à deux voies. Cela permet d’échanger de l’information plus librement entre le client et le serveur. Ceci est en contraste avec le web standard où le client devait faire toutes les demandes. </p>
                <p> <a href="https://www.npmjs.com/" > Npm</a> ou le Node Package Manager est un gestionnaire de dépendances qui propose des milliers de composantes pour simplifier l’implémentation de fonctionnalités dans une application web. Npm est utilisé pour gérer les composantes du côté serveur de façon à permettre la communication plus facilement avec le client. </p>
                <p> L’application est basée sur une base d’Angular générée par Yeoman. </p>
                <p> <a href="https://angularjs.org/" > Angular</a> est un cadriciel JavaScript créé par Google. Angular a été créé dans le but de plus facilement créer des applications dynamiques. Le cadriciel nous permet de lier dynamiquement des variables entre le DOM et le code pour faire en sorte que l’interface change automatiquement lorsque l’on change les variables dans le code. Il nous permet aussi de nous créer nos propres composantes pour ainsi simplifier l’intégration de vues dans notre code. </p>
                <p> <a href="http://yeoman.io/" > Yeoman</a> est un générateur d’applications web. Il permet aux utilisateurs de se créer des bases de projet selon la technologie qu’ils veulent utiliser. Les générateurs créés par les utilisateurs de Yeoman couvrent une grande quantité de produits. Il existe des générateurs pour Angular, Angular2, React, Flux, Redux, ASP.net, etc. Le générateur nous permet de créer l’architecture de base pour notre projet. En plus, le générateur nous crée automatiquement des fichiers de configuration pour le serveur et pour installer les dépendances. Dans certains cas, le générateur offre même la possibilité de se créer des dossiers de test. Pour pouvoir utiliser Yeoman, il est nécessaire d’avoir préalablement installé Npm. Dans le projet, nous avons utilisé le <a href="https://github.com/yeoman/generator-angular" >générateur angular</a>. </p>
                <p> Le générateur Yeoman generator-angular utilise Bower et Grunt. </p>
                <p> <a href="https://bower.io/" > Bower</a> est un gestionnaire de dépendance côté client. Comme Npm, Bower offre des milliers de composantes pour simplifier l’implémentation de fonctionnalités dans une application web. Ce qui diffère Npm de Bower est l’endroit où ils sont utilisés. Bower va être utilisé du côté client. Grâce à Bower, il est possible d’envoyer toute nos dépendances du côté client pour utiliser des librairies plus facilement. Il permet aussi de mieux gérer les versions de nos composantes et de faire nos mises à jour de celles-ci. Dans le projet, Bower est utilisé pour gérer la librairie D3. </p>
                <p> <a href="http://gruntjs.com/" > Grunt</a> est un task runner JavaScript. Un task runner est un type de composante qui permet de prendre plusieurs actions répétitives et de les rendre automatiques. Cela inclut la minification, la compilation, faire rouler les tests unitaires, etc. Pour utiliser Grunt, il suffit d’installer la composante et de rajouter un fichier de configuration Gruntfile.js qui déclare comment faire la compilation et comment faire rouler les tests. Dans le projet, Grunt est utilisé pour faire rouler le projet en local et rafraîchir le projet à chaque changement dans le code. En plus, il est utilisé pour pouvoir faire exécuter les tests unitaires. </p>
                <p> Les tests sont faits grâce au framework Karma et ils sont écrits avec Jasmine. </p>
                <p> <a href="https://karma-runner.github.io/" > Karma</a> est un framework de test JavaScript. Le framework se crée un serveur local de test où il peut exécuter les tests avec différents navigateurs. Dans notre cas, nous utilisons un faux navigateur nommé phantomJs qui permet de faire rouler des tests en background en utilisant un nombre minimal de ressources. Lorsque Karma exécute les tests, il utilise ce navigateur pour retrouver le résultat de notre code JavaScript et écrit en console le résultat de chaque test. </p>
                <p> <a href="http://jasmine.github.io/" > Jasmine</a> est un framework pour écrire des tests JavaScript. C’est un framework fait pour facilement tester le JavaScript. En effet, Jasmine n’a pas besoin de DOM et n’a pas besoin d’autres composantes pour fonctionner correctement. Jasmine est un framework fait pour tester le comportement et vérifier que le comportement retourne ce que l’on s’attend sans devoir passer par un DOM. </p>
                <p> Pour pouvoir faire afficher nos données, nous avons utilisé la librairie D3. </p>
                <p> <a href="https://d3js.org/" > D3</a> est une librairie JavaScript créée dans le but de pouvoir plus facilement manipuler le DOM selon des données et d’ainsi pouvoir créer des graphiques et autres sortes d’outils de représentation visuelle. D3 utilise des éléments standards d’HTML, de SVG et de CSS pour pouvoir représenter les données qui lui sont données. </p>
                <p> Combiné avec d’autres sous-composantes de D3, la librairie peut devenir extrêmement puissante. En effet, D3 offre des outils tel que D3-zoom pour pouvoir facilement zoomer dans notre élément graphique. D3-tip est une autre composante offerte qui nous permet de visualiser les données exactes d’un point en passant la souris par-dessus celui-ci. </p>
                <p> Ainsi, D3 permet de facilement créer des graphiques en donnant des outils pour faire des axes, des grilles, des légendes, des titres, etc. D3 permet aussi de créer des graphes, des chartes de bulles, des cartes, etc. D3 possède des bases pour une multitude d’outil et ils peuvent tous être utilisés les uns avec les autres pour créer une application complète. </p>
                <p> Pour pouvoir déployer notre application sur le web, nous avons utilisé Heroku. </p>
                <p> <a href="https://www.heroku.com/platform" > Heroku</a> est une plateforme infonuagique basée sur un principe de conteneurs pour permettre de déployer et de faire rouler des applications web. Heroku a une approche centrée sur les applications web pour permettre de facilement livrer un produit en s’assurant d’avoir un besoin minimal de configuration. Heroku offre un environnement avec tous les outils nécessaires pour faire rouler une application et qui est facile à maintenir. En plus, les forfaits de base sont gratuits. </p>
                <p> Pour pouvoir aller chercher nos données, nous avons utilisé un Docker sur lequel roule le site de champion.gg ce qui nous donne accès à sa base de données. </p>
                <p> <a href="https://champion.gg/" > Champion.gg</a> est un site web de statistique pour le populaire jeu League of Legends. Le site web est disponible publiquement sur Github. <a href="https://github.com/joel1st/championweb" >https://github.com/joel1st/championweb</a>. Le projet donne toutes les indications nécessaires pour pouvoir exécuter le projet localement et la base de données est entièrement disponible dans le projet. Cette base de données est faite en MongoDB et il est possible de faire quelques requêtes simples pour avoir toutes les statistiques venant du site web. </p>
                <p> <a href="https://www.docker.com/" > Docker est</a> un outil de développement qui permet de faire rouler des projets dans des conteneurs locaux pour avoir facilement accès à certains outils et à certains services sans devoir tout installé sur une machine de développement. Docker est une nouvelle alternative aux machines virtuelles, mais qui est beaucoup plus performante, plus simple à utiliser et plus facilement réutilisable. Docker permet de régler des problèmes de configuration en créant une seule application qui peut être utilisée partout et qui ne dépend pas d’outils externes à son conteneur. </p>
                <u>Versions: </u>
                <ul>
                    <li> Node.js: 6.6.0 </li>
                    <li> Npm: 3.10.7 </li>
                    <li> Yeoman: 1.8.5 </li>
                    <li> Generator-angular: 0.15.1</li>
                    <li> Angular: 1.5.8 </li>
                    <li> Bower: 1.7.9 </li>
                    <li> Grunt-cli: 1.2.0 </li>
                    <li> Grunt: 0.4.5 </li>
                    <li> Karma: 1.3.0 </li>
                    <li> Jasmine: 2.5.2 </li>
                    <li> D3: 3.5.17 </li>
                    <li> D3-tip: 0.7.1 </li>
                    <li> Heroku-cli: 5.4.8 </li>
                    <li> Heroku toolbelt: 3.43.13 </li>
                    <li> Docker: 1.12.2 </li>
                </ul>
            </div>
            <br>
            <div id="propositionLimites">
                <h4> Limites </h4>
                <p> Une de nos plus grosses limites dans ce projet est la question de performance. En effet, notre projet fonctionne, mais sur les ordinateurs moins puissants, on peut remarquer que le chargement de la page prend quelques secondes et qu’il y a un certain décalage lorsque l’on tente de faire un zoom dans le graphique.  </p>
                <p> La raison de ce décalage est dû principalement au grand nombre de données que nous avons dans notre graphique. En effet, avec les données de test que nous avons recueillies nous avons près de 200 points dans notre graphique. Chaque fois qu’un utilisateur fait un zoom dans le graphique, la position de chacun de ces 200 points doit être mise à jour. Puisqu’il est facilement possible de forcer plusieurs zooms un à la suite de l’autre (ce qui est voulu pour une interaction utilisateur plus naturelle), il est possible de demander très rapidement beaucoup de ressources pour l’exécution du script de la mise à jour des points. </p>
                <p> Si l’on aurait moins de points dans notre graphique, il y aurait certainement une forte hausse des performances. Par contre, puisque nous sommes limités dans le temps, nous n’avons pas trouvé de méthode d’augmenter la performance puisque nous voulions mettre l’accent sur les fonctionnalités et non sur les performances. </p>
                <p> Nous avons tout de même réussi à aller plus loin que nous aurions cru au départ. En effet, nous avions le sentiment qu’il nous serait impossible d’utiliser des données venant d’un contexte réel, mais grâce au site web Champion.gg, nous avons pu faciliter collecter des données venant du jeu en ligne League of Legends. Ce site web nous a offert une base de données ayant toutes les informations que nous souhaitions. Il nous a fallu simplement aller repeupler sa base de donnée sur notre propre poste et grâce à cela nous avons eu accès à toutes les informations pour faire notre graphique. </p>
                <p> Aussi, nous avions cru ne pas avoir le temps d’ajouter certaines fonctionnalités à notre graphique comme le zoom ou le filtre. Nous avons réussi à mettre en place ces fonctionnalités ce qui fait en sorte que notre graphique de démonstration est plus complet et plus représentatif de qu’un vrai graphique de ce type de donnée devrait ressembler. </p>
                <p> Il reste tout de même certaines fonctionnalités que nous aimerions implémenter. C’est-à-dire pouvoir changer quel type de donnée est géré par chacun des axes de façon à ce que les utilisateurs puissent comparer n’importe quel statistiques ensemble. </p>
                <p> Nos limites réelles en ce moment même sont le temps et les performances. Si nous avions plus de temps nous pourrions nous créer une composante plus complète pour rajouter les images facilement et rajouter d’autres fonctionnalités. Aussi les performances nous limitent, car on ne peut pas faire un graphique avec encore plus de données si l’on ne veut pas avoir de problèmes pour exécuter l’application. </p>
            </div>
        </div>
        <br>
        <div id="acquisitionConnaissances">
            <h3> Acquisition des connaissances </h3>
            <p> L’acquisition des connaissances s’est surtout faite sur la compréhension du fonctionnement de la librairie graphique D3. Par conséquent, nous n’allons pas expliquer le fonctionnement du cadriciel Angular, ni de toutes autres technologies utilisées pour réaliser notre projet. L’objectif principal du projet était de mettre des images dans un graphique pour simplifier la compréhension de celui-ci. Pour arriver à ce but, il n’aurait pas été nécessaire d’utiliser autre chose que D3. Les autres technologies servent à nous simplifier la tâche dans la conception de notre application, par conséquent il n’est pas nécessaire de décrire les connaissances acquises par celles-ci puisqu’elle n’aide pas à atteindre notre but.</p>
            <p> La conception du graphique se fait en plusieurs étapes: La définition du graphique (ses marges, l’endroit qu’il prend dans la page, les axes, etc.), le tip (permet de voir le point exact des données en passant la souris par-dessus celles-ci), la catégorisation par couleurs (selon des groupes logiques) et le zoom. </p>
            <div id="acquisitionGraphique">
                <h4> Base du graphique </h4>
            </div>
            <div id="acquisitionTip">
                <h4> Tip </h4>
            </div>
            <div id="acquisitionCategorisation">
                <h4> Catégorisation </h4>
            </div>
            <div id="acquisitionZoom">
                <h4> Zoom </h4>
            </div>
        </div>
        <br>
        <div id="demarcheExperimentale">
            <h3> Démarche expérimentale </h3>
            <p> Pour faire notre application, nous avons choisi d’utiliser Angular. Quoique nous n’avons pas beaucoup utilisé les outils d’Angular pour la gestion entre le DOM et le JavaScript, nous avons tout de même utilisé l’architecture propre à Angular. Nous avons utilisé un générateur Yeoman pour nous créer notre base de projet et ainsi pouvoir passer le plus de temps possible sur le développement de l’application. </p>
            <p> Le problème que nous voulions régler était l’impossibilité de représenter des images dans un graphique. Pour régler ce problème, nous avons dû premièrement trouver une librairie JavaScript qui nous permettrait de faire nos graphiques. </p>
            <p> Nous avons choisi d’utiliser D3. Celui-ci offre plusieurs avantages comparés à d’autres librairies graphiques. Un de ses avantages principaux est qu’il permet de faire plus de choses. En effet, à la base D3 existe pour manipuler le DOM, donc il n’est pas limité à créer des graphiques. Autrement dit, avec cette librairie il est plus facile de manipuler les images. En plus, D3 fonctionne directement avec le HTML, le SVG et le CSS ce qui fait en sorte qu’il est plus facilement compatible avec tous les navigateurs. </p>
            <p> D3 offre la possibilité de créer toutes sortes de graphiques. Par exemple, il est possible de faire des graphes, des nuages de points, des diagrammes à bandes, des diagrammes circulaires, etc. </p>
            <p> Dans notre application, nous avons utilisé un graphique de nuage de points. Pour faire ce nuage de points, nous avons dû utiliser les outils de base de D3 pour faire un graphique. C’est-à-dire d3-scale qui permet de gérer le domaine du graphique, d3-axis qui permet de gérer les axes du graphique et aussi l’outil de d3 qui permet de lier les points avec les données.  </p>
            <p> Par la suite, pour rendre notre graphique plus complet, nous avons rajouté d3-zoom et d3-tip. </p>
            <p> Bien sûr le but du projet était de mettre des images dans un graphique, alors nous avons dû trouver une façon de le faire avec la librairie D3. Le problème qui se trouve avec la gestion des images est que pour pouvoir insérer une image dans le graphique, il faut préalablement l’insérer dans le DOM. En effet, D3 ne fait que manipuler le DOM. Pour lier une image à un endroit dans le graphique, il faut que l’image soit préalablement là. </p>
            <p> Pour régler ce problème, nous devons absolument insérer dans le DOM des patterns contenant l’image que nous voulons ajouter et qui possède l’identifiant qui peut les relier à l’image. Par la suite, lorsque l’on place nos points dans le graphique, on peut se créer des cercles que l’on peut remplir avec l’identifiant nécessaire. </p>
            <pre>
            <code>
                <span class="text-info">var</span> loadImagePatterns = <span class="text-info">function</span>(svg, data, config){
                    <span class="text-info">var</span> <span class="text-primary">defs</span> = svg.append(<span class="text-success">"defs"</span>).attr(<span class="text-success">"id"</span>, <span class="text-success">"imgdefs"</span>);

                    data.forEach(<span class="text-info">function</span> (d) {
                        <b>//load les patterns avec l’id</b>
                        <span class="text-info">var</span> <span class="text-primary">champPattern</span> = <span class="text-primary">defs</span>.append(<span class="text-success">"pattern"</span>)
                        .attr(<span class="text-success">"id"</span>, <span class="text-success">"champ_avatar_"</span> + d.key + d.role)
                        .attr(<span class="text-success">"x"</span>, <span class="text-success">"0"</span>)
                        .attr(<span class="text-success">"y"</span>, <span class="text-success">"0"</span>);

                        <b>//rajoute les images avec le lien vers celle-ci</b>
                        <span class="text-primary">champPattern</span>.append(<span class="text-success">"image"</span>)
                            .attr(<span class="text-success">"height"</span>, config.avatar_size)
                            .attr(<span class="text-success">"width"</span>, config.avatar_size)
                            .attr(<span class="text-success">"xlink:href"</span>, <span class="text-success">"//ddragon.leagueoflegends.com/cdn/"</span>+
                            config.patchVersion+ <span class="text-success">"/img/champion/"</span> + d.key + <span class="text-success">".png"</span>);
                            });
                    };

                    <b>//Place Data</b>
                    <span class="text-primary">svg</span>.append(<span class="text-success">"g"</span>)
                        .selectAll(<span class="text-success">".dot"</span>)
                        .data(data)
                        .enter().append(<span class="text-success">"circle"</span>)
                        .attr(<span class="text-success">"r"</span>, <span class="text-primary">config</span>.avatar_size/2)
                        .style(<span class="text-success">"fill"</span>, <span class="text-info">function</span> (d) {
                        //remplis le cercle avec l’id créé plus tôt
                        <span class="text-info">return</span> <span class="text-success">"url(#champ_avatar_"</span> + d.key + d.role + ")";
                });
            </code>
            </pre>
            <p> Les outils d’expérimentation utilisés ont donc réussi à régler notre problème, mais la solution n’est pas optimale. En effet, faire toutes ces opérations n’est pas très efficace lorsque la quantité de données est élevée. </p>
            <p> Avant de commencer le projet, nous nous attendions à arriver à ce point et nous n’avions pas mis la performance comme une de nos priorités alors il est possible de dire avec confiance que les outils d’expérimentation ont réussi à régler notre problématique. </p>
            <p> Nos outils sont capables de bien représenter les données, ils nous donnent de nouveaux outils flexibles pour faire de la représentation de données dans le futur, ils ont permis de régler notre problème qui était de représenter des images dans un graphique et nous sommes arrivés au point auquel nous nous attendions. </p>
            <p> Au départ du projet, nous avions beaucoup d’incertitude par rapport aux outils que nous devrions utiliser. Nous ne savions pas si les outils que nous voulions utiliser étaient adéquats. Nous avions préalablement choisi d’utiliser le framework React, mais au cours de l’expérimentation, celui-ci s’est avéré à nous causer plus de problèmes alors nous avons décidé de l’abandonner pour plutôt utiliser Angular. </p>
            <p> Une autre de nos incertitudes était pour savoir quelle librairie graphique nous pourrions utiliser. Bien sûr, cette incertitude a été réglée, car D3 réglait tous nos problèmes par rapport à la librairie graphique. </p>
            <p> Il reste tout de même certaines incertitudes par rapport au projet. Premièrement, nous nous questionnons sur notre façon de gérer nos données. En effet, notre façon fonctionne, mais avec celle-ci nous restons dépendants d’un autre projet et si jamais celui-ci arrêterait, notre projet n’avancerait plus aussi bien. </p>
            <p> Aussi, nous ne savons pas comment pour l’instant nous pouvons augmenter les performances de l’application. Il est clair que nous devons créer une composante d3 pour mieux gérer la façon dont nous modifions nos images, mais pour l’instant nous ne savons pas encore quelle serait la meilleure façon de procéder. </p>
            <p> Au début du projet, nous voulions simplement créer une composante nous permettant de mettre les images dans notre graphique, mais au cours de la progression du projet nous avons changé un peu nos objectifs pour avoir un graphique plus complet. C’est-à-dire un graphique avec des données réelles et pouvant zoomer ainsi que de passer la souris pour voir les données exactes d’un point. Nous n’avons pas de composante, mais nous avons maintenant les connaissances pour pouvoir mettre des images dans un graphique. </p>
            <p> Notre expérimentation ressemble beaucoup à ce que nous voulions faire, mais avec un plus grand accent sur le visuel et un moins grand accent sur les composantes. </p>
        </div>
        <br>
        <div id="difficultes">
            <h3> Difficultés </h3>
        </div>
        <br>
        <div id="analyseResultats">
            <h3> Analyse des résultats </h3>
        </div>
        <br>
        <div id="conclusionRecherche">
            <h3> Conclusion de la recherche </h3>
        </div>
        <br>
        <div id="biliographie">
            <h3> Bibliographie: </h3>
            <p> Code source du projet: <a href="https://github.com/Thuranel/ImageChart/"> https://github.com/Thuranel/ImageChart/ </a> </p>
            <p> Blog du projet: <a href="http://ejsinc.blogspot.ca/"> http://ejsinc.blogspot.ca/ </a> </p>
            <p> Node team (8 nov. 2016), «Node.js», <i> Node.js </i>, <a href="https://nodejs.org/en/"> https://nodejs.org/en/ </a> </p>
            <p> Npm team (8 nov. 2016), «Npm», <i> Npm </i>, <a href="https://www.npmjs.com/"> https://www.npmjs.com/ </a> </p>
            <p> Angular team (8 nov. 2016), «Angular», <i> Angular </i>, <a href="https://angularjs.org/"> https://angularjs.org/ </a> </p>
            <p> Yeoman team (8 nov. 2016), «Yeoman», <i> Yeoman </i>, <a href="http://yeoman.io/"> http://yeoman.io/ </a> </p>
            <p> Yeoman team (8 nov. 2016), «generator-angular», <i> Generator Angular </i>, <a href="https://github.com/yeoman/generator-angular"> https://github.com/yeoman/generator-angular </a> </p>
            <p> Bower team (8 nov. 2016), «Bower», <i> Bower </i>, <a href="https://bower.io/"> https://bower.io/ </a> </p>
            <p> Grunt team (8 nov. 2016),  «Grunt», <i> Grunt </i>, <a href="http://gruntjs.com/"> http://gruntjs.com/ </a> </p>
            <p> Karma team (8 nov. 2016), «Karma», <i> Karma runner </i>, <a href="https://karma-runner.github.io/1.0/index.html"> https://karma-runner.github.io/1.0/index.html </a> </p>
            <p> Jasmine team (8 nov. 2016), «Jasmine», <i> Jasmine </i>, <a href="https://jasmine.github.io/"> https://jasmine.github.io/ </a> </p>
            <p> D3 team (8 nov. 2016), «D3», <i> D3js </i>, <a href="https://d3js.org/"> https://d3js.org/ </a> </p>
            <p> Heroku team (8 nov. 2016), «Heroku», <i> Heroku </i>, <a href="https://www.heroku.com/home"> https://www.heroku.com/home </a> </p>
            <p> joel1st (8 nov. 2016), «Champion.gg», <i> Champion.gg </i>, <a href="http://champion.gg/"> http://champion.gg/ </a> </p>
            <p> joel1st (8 nov. 2016), «Champion.gg Github», <i> Champion web </i>, <a href="https://github.com/joel1st/championweb"> https://github.com/joel1st/championweb </a> </p>
            <p> Docker team (8 nov. 2016), «Docker», <i> Docker </i>, <a href="https://www.docker.com/"> https://www.docker.com/ </a> </p>
            <p> Riot Games (8 nov. 2016), «League of Legends», <i> League of Legends </i>, <a href="http://na.leagueoflegends.com/"> http://na.leagueoflegends.com/ </a> </p>
        </div>
        <br>
    </div>
</div>
